<!-- Generated by SpecStory -->

# 解决Java空指针异常的方法 (2025-03-02 21:56:20)

_**User**_

java.lang.NullPointerException
 at com.hmdp.HmDianPingApplicationTests.testSaveShopToRedis(HmDianPingApplicationTests.java:20)
 at java.util.ArrayList.forEach(ArrayList.java:1249)
 at java.util.ArrayList.forEach(ArrayList.java:1249)

如何解决报错

---

_**Assistant**_

这个空指针异常（NullPointerException）很可能是因为测试类没有正确配置导致 `shopService` 没有被成功注入。在 JUnit 测试中，我们需要添加 `@SpringBootTest` 注解来确保 Spring 容器正确启动并注入所需的依赖。

让我们修改测试类：

```java:src/test/java/com/hmdp/HmDianPingApplicationTests.java
// ... existing code ...

@SpringBootTest // 添加这个注解
@MapperScan("com.hmdp.mapper")
@SpringBootApplication
public class HmDianPingApplicationTests {
    // ... existing code ...
}
```

修改说明：
1. 添加了 `@SpringBootTest` 注解，这个注解会创建一个完整的 Spring 应用程序上下文，确保所有的依赖注入都能正常工作
2. 实际上，在测试类中可能不需要 `@SpringBootApplication` 和 `@MapperScan` 注解，因为这些通常是在主应用程序类中使用的

如果还是遇到问题，请确认：
1. `ShopServiceImpl` 类是否已经用 `@Service` 注解标记
2. 项目的依赖是否都已正确配置（特别是 spring-boot-starter-test）
3. 是否有其他必要的配置文件（如 application.properties 或 application.yml）

---

_**User**_

ava.lang.IllegalStateException: Found multiple @SpringBootConfiguration annotated classes [Generic bean: class [com.hmdp.HmDianPingApplicationTests]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\new_proj\hmdp-init\target\test-classes\com\hmdp\HmDianPingApplicationTests.class], Generic bean: class [com.hmdp.HmDianPingApplication]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\new_proj\hmdp-init\target\classes\com\hmdp\HmDianPingApplication.class]]
如何解决

---

_**Assistant**_

这个错误是因为同时存在两个被 `@SpringBootConfiguration` 注解标记的类（实际上 `@SpringBootApplication` 包含了 `@SpringBootConfiguration`）。一个在测试类中，一个在主应用程序类中。

让我们修改测试类，移除不必要的注解：

```java:src/test/java/com/hmdp/HmDianPingApplicationTests.java
package com.hmdp;

import javax.annotation.*;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import com.hmdp.service.impl.ShopServiceImpl;

@SpringBootTest
public class HmDianPingApplicationTests {

    @Resource
    private ShopServiceImpl shopService;

    @Test
    public void testSaveShopToRedis(){
        shopService.saveShopToRedis(1L, 20L);
    }
}
```

修改说明：
1. 移除了 `@MapperScan` 注解，因为这个注解已经在主应用程序类中定义
2. 移除了 `@SpringBootApplication` 注解，因为测试类不需要这个注解
3. 只保留 `@SpringBootTest` 注解，这个注解足够支持测试环境的依赖注入

这样修改后，Spring Boot 就只会找到一个主配置类（主应用程序中的 `@SpringBootApplication`），错误应该就解决了。

---

_**User**_

如何解决上诉报错问题

---

_**Assistant**_

这个错误是因为从 Redis 中获取的 JSONObject 对象无法直接转换为 Shop 实体类。我们需要在 ShopServiceImpl 中正确处理 JSON 转换。

让我们修改 ShopServiceImpl 类：

```java:src/main/java/com/hmdp/service/impl/ShopServiceImpl.java
public class ShopServiceImpl {
    // ... existing code ...
    
    public Shop queryWithLogical(Long id) {
        String key = CACHE_SHOP_KEY + id;
        // 从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        
        // 修改这里的转换逻辑
        if (StrUtil.isNotBlank(shopJson)) {
            // 使用JSONUtil.toBean而不是直接转换
            return JSONUtil.toBean(shopJson, Shop.class);
        }
        
        // ... existing code ...
    }
}
```

修改说明：
1. 问题出在 JSON 对象到 Shop 实体的转换过程中
2. 使用 Hutool 的 `JSONUtil.toBean()` 方法来正确地将 JSON 字符串转换为 Shop 对象
3. 确保从 Redis 中获取的是 JSON 字符串，而不是 JSONObject

另外，请确保：
1. Shop 类有正确的 getter 和 setter 方法
2. Shop 类有无参构造函数
3. 存入 Redis 时使用的是 JSON 字符串格式

如果你想查看存入 Redis 的具体数据格式，可以使用 Redis 客户端工具查看对应的 key 值，确保数据格式正确。

---

_**User**_

以上你的修改并不正确，我经过上述引用的修改成功解决bug，但我没有理解为什么转换过程为：shopJson→redisData→shop，有没有办法进行简化呢？

---

_**Assistant**_

让我解释一下这个转换过程：

1. 当前转换流程：

```157:159:src/main/java/com/hmdp/service/impl/ShopServiceImpl.java
        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
        // 将redisData中的data转换为Shop对象
        Shop shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class);
```


这个两步转换是因为我们在存储时使用了 `RedisData` 包装类来存储额外的信息（比如过期时间）。

2. 简化方案：
如果你不需要逻辑过期功能，可以直接将 Shop 对象存入 Redis，这样就可以一步完成转换：

```java
// 存储时
stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));

// 读取时
Shop shop = JSONUtil.toBean(shopJson, Shop.class);
```

但是不建议这样简化，因为：
1. `RedisData` 包装类提供了过期时间等元数据信息
2. 这种设计模式使得数据结构更加清晰和可扩展
3. 方便后续添加其他缓存控制功能

如果你想在保留功能的同时优化代码，可以这样写：

```java
public Shop queryWithLogical(Long id) {
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    if(StrUtil.isBlank(shopJson)) {
        return null;
    }
    
    // 一次性完成反序列化
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    Shop shop = (Shop) redisData.getData();
    
    // 判断是否过期
    LocalDateTime expireTime = redisData.getExpireTime();
    if(expireTime.isAfter(LocalDateTime.now())) {
        return shop;
    }
    // ... 后续逻辑
}
```

这样虽然还是两步转换，但代码更简洁，而且保留了所有功能。

---

_**User**_

Shop shop = (Shop) redisData.getData();如此强行转化类型是合法的吗，redisData中不还拥有expireTime这种Shop类3中未定义的字段吗

---

_**Assistant**_

这个问题问得很好。直接使用 `(Shop) redisData.getData()` 确实是不安全的，因为：

1. `RedisData` 类中的 `data` 字段是 `Object` 类型：

```8:11:src/main/java/com/hmdp/utils/RedisData.java
public class RedisData {
    private LocalDateTime expireTime;
    private Object data;
}
```


2. 当我们将数据存入 Redis 时，数据经历了以下转换：
   - Shop 对象 → JSON 字符串 → 存入 Redis
   - 从 Redis 读取 → JSON 字符串 → RedisData 对象（其中 data 字段是 JSONObject）

3. 正确的做法应该是：

```java
public Shop queryWithLogical(Long id) {
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    if(StrUtil.isBlank(shopJson)) {
        return null;
    }
    
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    // 使用JSONUtil进行安全的类型转换
    JSONObject data = (JSONObject) redisData.getData();
    Shop shop = JSONUtil.toBean(data, Shop.class);
    
    // ... 后续逻辑
}
```

这样做的好处是：
1. 类型转换更加安全，避免了强制类型转换可能带来的 ClassCastException
2. 充分利用了 JSONUtil 的类型转换功能，确保数据的正确性
3. 代码的可读性和可维护性更好

总的来说，直接使用 `(Shop) redisData.getData()` 是不安全的，应该使用 JSON 工具类进行正确的类型转换。

---



---

