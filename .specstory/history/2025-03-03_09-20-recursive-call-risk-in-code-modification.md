<!-- Generated by SpecStory -->

# Recursive Call Risk in Code Modification (2025-03-03 17:20:19)

_**User**_

以上代码在完成以下104-111行的修改后，是否还会出现递归调用 queryWithMutex()导致的栈溢出问题的风险呢？

---

_**Assistant**_

<think>
好的，我现在需要分析用户的问题。用户询问在修改了代码的104-111行后，是否还存在递归调用queryWithMutex()导致栈溢出的风险。首先，我需要确定用户提到的代码行数对应的具体代码块。

根据用户提供的代码片段，尤其是第二个特别相关的代码段，其中包含：

```java
        boolean isLock = false;
        
        try {
            // 4.2 判断是否获取成功
            // 循环获取锁 避免递归
            while (!(isLock = tryLock(lock_key))) {
                Thread.sleep(50);
            }
```

这里的循环是在获取互斥锁，如果获取失败，会不断重试，而不是递归调用。原来的代码中，用户可能担心在获取锁失败时，会递归调用queryWithMutex()，导致栈溢出。但根据当前代码，使用的是while循环来等待锁，而不是递归调用。因此，修改后的代码通过循环避免了递归，从而消除了栈溢出的风险。

需要确认代码中是否有其他地方调用了queryWithMutex()自身。查看用户提供的queryWithMutex方法，发现没有递归调用，所有逻辑都在同一个方法内通过循环处理。因此，栈溢出不会发生，因为循环不会增加调用栈深度。

总结：修改后的代码使用循环而非递归来获取锁，因此不会导致栈溢出。
</think>

根据代码中的关键片段：


```109:111:src/main/java/com/hmdp/service/impl/ShopServiceImpl.java
            while (!(isLock = tryLock(lock_key))) {
                Thread.sleep(50);
            }
```


修改后的代码使用 `while` 循环代替了递归调用，通过不断轮询尝试获取锁（间隔 50ms）的方式避免了递归调用。这种实现方式：

1. 消除了递归调用导致的栈溢出风险
2. 通过非阻塞的轮询机制实现锁等待
3. 保持线程在同一个方法调用栈中运行

当前实现中，当获取锁失败时会进入循环等待状态，而不是递归调用自身，因此不会产生新的调用栈帧。只有当成功获取锁后才会继续执行后续逻辑，这种设计是典型的自旋锁实现方式，可以有效避免栈溢出问题。

---



---

