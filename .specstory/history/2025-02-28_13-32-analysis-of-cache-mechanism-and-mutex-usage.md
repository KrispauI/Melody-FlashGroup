<!-- Generated by SpecStory -->

# Analysis of Cache Mechanism and Mutex Usage (2025-02-28 21:32:06)

_**User**_

帮我分析上述代码的可用性与性能，能否合理使用互斥锁来解决缓存击穿问题，是否存在一些潜在风险。其中用到的递归查询queryWithMutex(id); 是否会造成潜在的栈溢出问题



---

_**Assistant**_

让我分析一下这段代码的几个关键点：

### 1. 互斥锁解决缓存击穿的可行性

这段代码使用Redis实现分布式互斥锁来解决缓存击穿问题，整体思路是正确的：

```java
startLine: 94
endLine: 98
```

通过`setIfAbsent`(setnx)实现互斥锁，这是一个比较标准的实现方式。

### 2. 存在的潜在问题

1. **递归调用风险**:
```java
startLine: 100
endLine: 102
```
当获取锁失败时直接递归调用自身，可能导致以下问题：
- 栈溢出风险：如果大量线程同时访问，递归深度可能会很大
- 性能问题：每次递归都会创建新的栈帧，消耗内存

2. **锁的释放问题**:
```java
startLine: 119
endLine: 124
```
虽然使用了try-finally确保锁的释放，但如果发生以下情况可能会有问题：
- 服务宕机
- Redis连接异常
- 程序异常退出

3. **缓存重建的双重检查**:
```java
startLine: 104
endLine: 109
```
虽然实现了双重检查，但在高并发场景下仍可能造成多次数据库查询。

### 3. 性能分析

1. **响应时间**:
- 获取锁失败后休眠50ms再重试，在高并发场景下可能导致较长的响应时间
- 递归调用会增加调用栈深度，影响性能

2. **资源消耗**:
- 频繁的Redis访问
- 递归调用导致的内存消耗
- 潜在的数据库压力

### 4. 改进建议

1. **替换递归为循环**:
```java
public Shop queryWithMutex(Long id) {
    String lock_key = LOCK_SHOP_KEY + id;
    Shop shop = null;
    int retryCount = 0;
    while (retryCount < MAX_RETRY) {
        if (tryLock(lock_key)) {
            try {
                return queryWithCache(id);
            } finally {
                unlock(lock_key);
            }
        }
        retryCount++;
        Thread.sleep(50);
    }
    return null; // 或抛出异常
}
```

2. **增加锁超时机制**:
```java
private boolean tryLock(String key){
    return stringRedisTemplate.opsForValue()
        .setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
}
```

3. **使用布隆过滤器**:
- 在缓存之前加入布隆过滤器，减少无效查询
- 降低缓存穿透的可能性

4. **优化缓存策略**:
- 考虑使用多级缓存
- 实现定时预热机制
- 采用异步更新策略

总的来说，虽然当前实现基本可用，但在高并发场景下可能存在性能和稳定性问题。建议根据实际业务场景进行优化，特别是替换递归实现，增加超时机制等关键改进。

---

_**User**_

该逻辑过期解决缓存击穿问题的策略，需要如何修改代码以实现 获取锁成功，再次查询redis缓存，查询数据库

---

_**Assistant**_

让我分析一下逻辑过期方案的实现，并提供改进建议：

### 1. 当前实现的问题

1. **重复查询问题**:
```java
startLine: 171
endLine: 182
```
获取锁成功后直接异步重建缓存，没有进行双重检查，可能导致重复的缓存重建操作。

2. **递归调用风险**:
```java
startLine: 182
endLine: 182
```
直接递归调用`queryWithLogical(id)`可能导致栈溢出。

### 2. 改进建议

建议修改为以下实现：

```java
public Shop queryWithLogical(Long id) {
    // 1. 从redis查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    // 2. 判断是否存在
    if (StrUtil.isBlank(shopJson)) {
        return null;
    }
    
    // 4. 命中，反序列化
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    Shop shop = (Shop) redisData.getData();
    LocalDateTime expireTime = redisData.getExpireTime();
    
    // 5. 判断是否过期
    if (expireTime.isAfter(LocalDateTime.now())) {
        // 5.1 未过期，直接返回
        return shop;
    }
    
    // 6. 过期，尝试获取互斥锁
    String lockKey = LOCK_SHOP_KEY + id;
    boolean isLock = tryLock(lockKey);
    
    try {
        if (isLock) {
            // 6.1 获取锁成功，再次检查Redis缓存
            shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
            if (StrUtil.isNotBlank(shopJson)) {
                // 其他线程已经重建完成，直接返回
                redisData = JSONUtil.toBean(shopJson, RedisData.class);
                return (Shop) redisData.getData();
            }
            
            // 6.2 使用线程池异步重建缓存
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    // 查询数据库
                    Shop newShop = getById(id);
                    // 重建缓存
                    saveShopToRedis(id, 20L);
                } catch (Exception e) {
                    log.error("重建缓存异常", e);
                } finally {
                    unlock(lockKey);
                }
            });
        }
    } catch (Exception e) {
        unlock(lockKey);
        throw new RuntimeException("缓存重建异常", e);
    }
    
    // 7. 返回过期的商铺信息
    return shop;
}
```

### 3. 主要改进点

1. **增加双重检查**:
- 获取锁成功后，再次检查Redis缓存
- 避免重复的缓存重建操作

2. **移除递归调用**:
- 不再使用递归方式重新查询
- 返回过期数据，保证可用性

3. **异常处理优化**:
- 完善try-catch结构
- 确保锁的释放
- 添加日志记录

4. **缓存预热建议**:
```java
public void warmupCache(Long id) {
    Shop shop = getById(id);
    if (shop != null) {
        saveShopToRedis(id, 20L);
    }
}
```

### 4. 其他建议

1. **配置优化**:
- 线程池参数可配置化
- 过期时间可配置化
- 增加监控指标

2. **可用性保证**:
- 考虑添加降级策略
- 增加熔断机制
- 设置合理的超时时间

这样的实现既保证了缓存击穿的防护，又避免了原有实现中的潜在问题，同时保证了数据的可用性。

---

_**User**_

缓存预热起到的是什么作用

---

_**Assistant**_

缓存预热（Cache Warmup）是一个非常重要的缓存策略，让我为您详细解释：

### 1. 缓存预热的作用

1. **防止冷启动问题**：
```java
public void warmupCache(List<Long> hotShopIds) {
    // 并行处理热点数据预热
    hotShopIds.parallelStream().forEach(id -> {
        // 查询数据库
        Shop shop = getById(id);
        // 写入缓存
        saveShopToRedis(id, 20L);
    });
}
```

2. **避免缓存击穿**：
```java
public void saveShopToRedis(Long id, Long expireSeconds) {
    Shop shop = getById(id);
    RedisData redisData = new RedisData();
    redisData.setData(shop);
    // 设置逻辑过期时间
    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));
    // 写入Redis，不设置TTL
    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));
}
```

### 2. 预热时机

1. **系统启动时**：
```java
@PostConstruct
public void init() {
    // 获取热点商铺ID列表
    List<Long> hotShopIds = getHotShopIds();
    // 执行预热
    warmupCache(hotShopIds);
}
```

2. **定时刷新**：
```java
@Scheduled(cron = "0 0 0 * * ?") // 每天零点执行
public void refreshCache() {
    List<Long> hotShopIds = getHotShopIds();
    warmupCache(hotShopIds);
}
```

### 3. 预热策略

1. **分批预热**：
```java
public void batchWarmup(List<Long> shopIds, int batchSize) {
    for (int i = 0; i < shopIds.size(); i += batchSize) {
        int end = Math.min(i + batchSize, shopIds.size());
        List<Long> batch = shopIds.subList(i, end);
        warmupCache(batch);
        // 适当休眠，避免数据库压力过大
        Thread.sleep(100);
    }
}
```

2. **优先级预热**：
```java
public void priorityWarmup(Map<Long, Integer> shopScores) {
    // 按照分数排序
    List<Long> sortedShops = shopScores.entrySet().stream()
        .sorted(Map.Entry.<Long, Integer>comparingByValue().reversed())
        .map(Map.Entry::getKey)
        .collect(Collectors.toList());
    
    warmupCache(sortedShops);
}
```

### 4. 预热的优势

1. **提升系统启动后的访问性能**
- 避免系统启动初期大量缓存miss
- 减少数据库压力

2. **控制缓存击穿**
- 热点数据提前加载
- 使用逻辑过期策略

3. **更好的用户体验**
- 减少用户等待时间
- 提供稳定的响应时间

### 5. 注意事项

1. **内存管理**：
```java
public void warmupWithMemoryControl() {
    // 获取Redis内存使用情况
    Long maxMemory = getRedisMaxMemory();
    Long usedMemory = getRedisUsedMemory();
    
    // 根据内存使用情况调整预热策略
    if (usedMemory > maxMemory * 0.8) {
        // 执行清理或限制预热
        cleanCache();
    }
}
```

2. **监控和告警**：
```java
public void monitorWarmup(Long shopId) {
    try {
        long start = System.currentTimeMillis();
        saveShopToRedis(shopId, 20L);
        long cost = System.currentTimeMillis() - start;
        
        // 记录预热耗时
        if (cost > 1000) {
            log.warn("缓存预热耗时过长: shopId={}, cost={}ms", shopId, cost);
        }
    } catch (Exception e) {
        // 发送告警
        sendAlert("缓存预热异常: " + shopId);
        log.error("缓存预热异常", e);
    }
}
```

### 6. 实际应用建议

1. **选择性预热**：
- 根据访问频率
- 根据业务重要性
- 根据数据量大小

2. **动态调整**：
- 监控缓存命中率
- 适时调整预热策略
- 根据系统负载调整

缓存预热是一个系统性能优化的重要手段，合理使用可以显著提升系统的稳定性和响应速度。但需要根据实际业务场景和系统资源情况来制定合适的预热策略。

---

_**User**_

以上代码如果不进行缓存预热，是否会出现空指针异常的问题

---

_**Assistant**_

让我分析一下这段代码可能出现的问题：

### 1. 空指针风险分析

```java
RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
Shop shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class);
```

如果不进行缓存预热，可能会出现以下场景：

1. **初始状态下Redis没有缓存**
   - `shopJson` 为 null
   - 直接返回 null
   - 不会触发空指针异常

2. **缓存中数据不完整**
   - `redisData.getData()` 可能为 null
   - 强制类型转换 `(JSONObject)` 时可能抛出 `NullPointerException`

### 2. 解决方案

```java
public Shop queryWithLogical(Long id){
    // 1. 从redis中查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    
    // 2. 判断是否存在
    if(StrUtil.isBlank(shopJson)){
        return null;
    }
    
    // 3. 安全的反序列化
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    
    // 4. 增加非空检查
    if(redisData == null || redisData.getData() == null){
        return null;
    }
    
    // 5. 安全转换
    Shop shop = null;
    try {
        shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class);
    } catch (Exception e) {
        // 记录日志或处理异常
        return null;
    }
    
    // 6. 判断是否过期逻辑
    LocalDateTime expireTime = redisData.getExpireTime();
    if(expireTime == null || expireTime.isAfter(LocalDateTime.now())){
        return shop;
    }
    
    // 后续缓存重建逻辑...
}
```

### 3. 缓存预热的重要性

缓存预热可以：
1. 提前将热点数据加载到缓存
2. 避免首次访问时的性能开销
3. 减少数据库压力
4. 提供更稳定的系统响应

### 4. 预热实现示例

```java
@PostConstruct  // 项目启动时执行
public void initCache() {
    // 获取热点商铺ID列表
    List<Long> hotShopIds = getHotShopIds();
    
    for (Long shopId : hotShopIds) {
        saveShopToRedis(shopId, 20L);
    }
}

private List<Long> getHotShopIds() {
    // 根据业务逻辑获取热点商铺ID
    // 可以是访问量高的商铺、推荐商铺等
    return shopMapper.selectHotShopIds();
}
```

### 5. 总结

1. 不进行缓存预热，可能会出现空指针风险
2. 通过安全的反序列化和非空检查可以缓解风险
3. 缓存预热是提升系统性能和稳定性的重要手段

建议在项目启动时或定期执行缓存预热，并添加必要的异常处理机制。

---

_**User**_

以上代码理论上已经避免了当没有进行缓存预热时，查不到缓存数据的情况，但现在我只能访问到进行过缓存预热的shop值，没有进行预热的商铺就无法缓存到，观察日志发现代码并没有去对mysql数据库查询，请你帮我分析原因

---

_**Assistant**_

让我分析一下可能的原因：

### 1. 代码执行流程分析

```java
public Shop queryWithLogical(Long id){
    // 1. 从redis中查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    
    // 2. 如果缓存不存在
    if(StrUtil.isBlank(shopJson)){
        // 直接返回null，没有进一步的数据库查询逻辑
        return null;
    }
    
    // 后续反序列化和缓存重建逻辑...
}
```

### 2. 问题根源

1. **缺少数据库兜底查询**
   - 当Redis中不存在数据时，直接返回null
   - 没有调用`getById(id)`进行数据库查询
   - 未实现缓存穿透的兜底策略

### 3. 修复建议

```java
public Shop queryWithLogical(Long id){
    // 1. 从redis中查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    
    // 2. 如果缓存不存在
    if(StrUtil.isBlank(shopJson)){
        // 查询数据库
        Shop shop = getById(id);
        
        // 如果数据库也没有
        if(shop == null){
            // 写入空值到Redis，防止缓存穿透
            stringRedisTemplate.opsForValue().set(
                CACHE_SHOP_KEY + id, 
                "", 
                CACHE_NULL_TTL, 
                TimeUnit.MINUTES
            );
            return null;
        }
        
        // 数据库有数据，则写入缓存
        saveShopToRedis(id, 20L);
        return shop;
    }
    
    // 后续缓存处理逻辑...
}
```

### 4. 完整的缓存策略

```java
public Shop queryWithLogical(Long id) {
    // 1. 尝试从Redis获取
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    
    // 2. 缓存未命中
    if (StrUtil.isBlank(shopJson)) {
        // 查询数据库
        return handleDbQuery(id);
    }
    
    // 3. 反序列化缓存数据
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    
    // 4. 检查数据有效性
    if (redisData == null || redisData.getData() == null) {
        return handleDbQuery(id);
    }
    
    // 5. 转换数据
    Shop shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class);
    
    // 6. 检查缓存是否过期
    LocalDateTime expireTime = redisData.getExpireTime();
    if (expireTime.isAfter(LocalDateTime.now())) {
        return shop;
    }
    
    // 7. 缓存重建逻辑
    return rebuildCache(id, shop);
}

// 数据库查询兜底方法
private Shop handleDbQuery(Long id) {
    Shop shop = getById(id);
    
    if (shop == null) {
        // 防止缓存穿透
        stringRedisTemplate.opsForValue().set(
            CACHE_SHOP_KEY + id, 
            "", 
            CACHE_NULL_TTL, 
            TimeUnit.MINUTES
        );
        return null;
    }
    
    // 写入缓存
    saveShopToRedis(id, 20L);
    return shop;
}

// 缓存重建方法
private Shop rebuildCache(Long id, Shop oldShop) {
    String lockKey = LOCK_SHOP_KEY + id;
    
    if (tryLock(lockKey)) {
        try {
            // 异步重建缓存
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    saveShopToRedis(id, 20L);
                } finally {
                    unlock(lockKey);
                }
            });
        } catch (Exception e) {
            unlock(lockKey);
        }
    }
    
    // 返回旧数据
    return oldShop;
}
```

### 5. 关键改进点

1. 增加数据库兜底查询
2. 实现缓存穿透防护
3. 优化缓存重建流程
4. 提供更健壮的缓存处理逻辑

### 6. 注意事项

1. 合理设置缓存过期时间
2. 控制数据库查询频率
3. 添加必要的异常处理
4. 考虑性能和资源消耗

这个改进后的方案能够：
- 处理未预热的商铺数据
- 防止缓存穿透
- 提供更稳定的缓存查询机制

---

_**User**_

成功地解决了问题，但我认为你对于缓存穿透的处理存在一些瑕疵，你可以参照我之前所实现的这个queryWithPassThrough方法，进一步完善缓存穿透的处理

---

_**Assistant**_

您的`queryWithPassThrough`方法已经很好地处理了缓存穿透的问题，但我可以提供一些微小的改进建议：

```java
public Shop queryWithPassThrough(Long id) {
    // 1. 从Redis查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);

    // 2. 缓存命中直接返回
    if (StrUtil.isNotBlank(shopJson)) {
        return JSONUtil.toBean(shopJson, Shop.class);
    }

    // 3. 命中空值缓存
    if (shopJson != null) {
        return null;
    }

    // 4. 查询数据库
    Shop shop = getById(id);   

    // 5. 数据库未查到，写入空值并返回null
    if (shop == null) {
        // 防止缓存穿透，写入空值，过期时间较短
        stringRedisTemplate.opsForValue().set(
            CACHE_SHOP_KEY + id, 
            "", 
            CACHE_SHOP_NULL_TTL, 
            TimeUnit.MINUTES
        );
        return null;
    }

    // 6. 写入Redis缓存
    stringRedisTemplate.opsForValue().set(
        CACHE_SHOP_KEY + id, 
        JSONUtil.toJsonStr(shop), 
        CACHE_SHOP_TTL, 
        TimeUnit.MINUTES
    );

    return shop;
}
```

### 主要改进点

1. **代码简化**
   - 减少不必要的临时变量
   - 优化代码结构，提高可读性

2. **缓存写入优化**
   - 使用链式调用
   - 明确指定过期时间和单位

3. **空值缓存处理**
   - 保持原有的防缓存穿透策略
   - 对于不存在的数据，写入短期空值缓存

4. **异常处理**
   - 避免潜在的空指针风险
   - 保持代码的健壮性

### 缓存穿透防护策略

1. **空值缓存**
   - 对于查询不到的数据，写入短期空缓存
   - 有效期通常设置为2-5分钟

2. **布隆过滤器**（可选）
   - 在查询Redis前，先通过布隆过滤器快速判断
   - 减少不必要的数据库查询

3. **参数校验**
   - 对输入参数进行合法性检查
   - 防止恶意的大量无效查询

### 性能与资源考虑

1. 合理设置缓存过期时间
2. 控制空值缓存的数量
3. 监控缓存命中率
4. 根据业务特点调整策略

这个实现保持了原有代码的核心逻辑，同时提供了更加简洁和健壮的缓存穿透解决方案。

---

_**User**_

但我认为你在这部分为了防止缓存穿透，向缓存中加入了空值，但如果之后缓存命中了空值，你如何在queryWithLogical方法中对这一情况进行特判处理呢？

---

_**Assistant**_

非常好的问题！在`queryWithLogical`方法中，我们需要特别处理空值缓存的情况。以下是一个优化的实现：

```java
public Shop queryWithLogical(Long id){
    // 1. 从redis中查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    
    // 2. 判断是否存在
    if(StrUtil.isBlank(shopJson)){
        // 3. 处理数据库查询
        return handleDbQuery(id);
    }
    
    // 4. 特殊处理：检查是否为空值缓存
    if("".equals(shopJson)){
        // 如果是空值缓存，直接返回null
        return null;
    }
    
    // 5. 反序列化缓存数据
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    
    // 6. 检查数据有效性
    if(redisData == null || redisData.getData() == null){
        return handleDbQuery(id);
    }
    
    // 7. 转换数据
    Shop shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class);
    
    // 8. 检查缓存是否过期
    LocalDateTime expireTime = redisData.getExpireTime();
    if(expireTime.isAfter(LocalDateTime.now())){
        return shop;
    }
    
    // 9. 缓存重建逻辑
    return rebuildCache(id, shop);
}

// 数据库查询兜底方法
private Shop handleDbQuery(Long id) {
    Shop shop = getById(id);
    
    if (shop == null) {
        // 防止缓存穿透，写入空值
        stringRedisTemplate.opsForValue().set(
            CACHE_SHOP_KEY + id, 
            "", 
            CACHE_NULL_TTL, 
            TimeUnit.MINUTES
        );
        return null;
    }
    
    // 写入缓存
    saveShopToRedis(id, 20L);
    return shop;
}

// 缓存重建方法
private Shop rebuildCache(Long id, Shop oldShop) {
    String lockKey = LOCK_SHOP_KEY + id;
    
    if (tryLock(lockKey)) {
        try {
            // 异步重建缓存
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    saveShopToRedis(id, 20L);
                } finally {
                    unlock(lockKey);
                }
            });
        } catch (Exception e) {
            unlock(lockKey);
        }
    }
    
    // 返回旧数据
    return oldShop;
}
```

### 主要改进点

1. **空值缓存特判**
   ```java
   if("".equals(shopJson)){
       // 直接返回null，表示数据不存在
       return null;
   }
   ```
   - 明确区分空值缓存和正常缓存
   - 避免不必要的反序列化操作

2. **数据库查询兜底**
   ```java
   private Shop handleDbQuery(Long id) {
       Shop shop = getById(id);
       
       if (shop == null) {
           // 写入空值缓存
           stringRedisTemplate.opsForValue().set(
               CACHE_SHOP_KEY + id, 
               "", 
               CACHE_NULL_TTL, 
               TimeUnit.MINUTES
           );
           return null;
       }
       
       // 正常写入缓存
       saveShopToRedis(id, 20L);
       return shop;
   }
   ```

3. **多重数据有效性检查**
   - 检查缓存是否为空
   - 检查反序列化后的对象是否有效
   - 检查缓存是否过期

### 缓存穿透防护策略

1. **空值缓存**
   - 对于查询不到的数据，写入空字符串缓存
   - 过期时间短（2-5分钟）
   - 防止恶意大量无效查询

2. **查询流程**
   - 先检查缓存
   - 命中空值缓存直接返回null
   - 未命中则查询数据库
   - 数据库未查到则写入空值缓存

### 性能与资源考虑

1. 减少不必要的数据库查询
2. 控制空值缓存数量
3. 设置合理的缓存过期时间
4. 异步重建缓存，降低响应延迟

这个实现提供了一个更加健壮和高效的缓存穿透解决方案，同时保持了代码的简洁性和可读性。

---

_**User**_

 if("".equals(shopJson))这个判断条件是否合法呢？会不会抛出NullPointerException

---

_**Assistant**_

您提出了一个非常好的问题。让我详细分析一下：

### 空值判断的风险

```java
if("".equals(shopJson))
```

这种写法存在潜在的空指针风险。当`shopJson`为`null`时，会直接抛出`NullPointerException`。

### 安全的判断方式

1. **推荐方案1**：先判断非空
```java
if (shopJson != null && "".equals(shopJson)) {
    return null;
}
```

2. **推荐方案2**：使用`StrUtil.isBlank()`
```java
if (StrUtil.isBlank(shopJson)) {
    return handleDbQuery(id);
}
```

3. **推荐方案3**：使用`Objects.equals()`
```java
if (Objects.equals(shopJson, "")) {
    return null;
}
```

### 最佳实践

```java
public Shop queryWithLogical(Long id){
    // 1. 从redis中查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
    
    // 2. 安全的空值判断
    if (shopJson == null) {
        // 处理数据库查询
        return handleDbQuery(id);
    }
    
    // 3. 空字符串处理
    if ("".equals(shopJson)) {
        return null;
    }
    
    // 后续逻辑...
}
```

### 推荐原因

1. 避免空指针异常
2. 代码更加健壮
3. 逻辑更加清晰
4. 遵循防御性编程原则

---



---

