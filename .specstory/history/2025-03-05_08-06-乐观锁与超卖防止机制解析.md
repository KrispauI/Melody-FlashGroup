<!-- Generated by SpecStory -->

# 乐观锁与超卖防止机制解析 (2025-03-05 16:06:09)

_**User**_

我对乐观锁不算特别了解，请为我解析这段使用乐观锁防止超卖的代码

---

_**Assistant**_

我来为您解释这段使用乐观锁的代码。

乐观锁的核心思想是：在更新数据时，假设数据不会被其他线程修改。但在更新前，会先检查数据是否与预期一致，如果一致才更新，否则放弃更新。

让我们分析这段代码：

```java:src/main/java/com/hmdp/service/impl/VoucherOrderServiceImpl.java
boolean success = voucherService.update()
    .setSql("stock = stock - 1")                              // 1️⃣ 库存-1
    .eq("voucher_id", voucherId)                             // 2️⃣ 匹配优惠券id
    .eq("stock", voucher.getStock())                         // 3️⃣ 检查当前库存是否与查询时一致
    .update();
```

这里的乐观锁实现可以分为几个关键点：

1. **版本控制**：使用库存值`stock`本身作为版本号
   - 通过`.eq("stock", voucher.getStock())`确保当前库存数量与最初查询时一致

2. **更新机制**：
   - 如果库存值与查询时一致，说明期间没有其他线程修改过，更新成功
   - 如果库存值已变化，说明其他线程已经修改过，更新失败

3. **防止超卖原理**：
   假设库存为1，两个线程同时购买：
   - 线程A和线程B同时读取到stock=1
   - 线程A执行更新，条件是stock=1，更新成功
   - 线程B执行更新，条件仍是stock=1，但此时实际stock=0，更新失败
   - 从而避免了超卖问题

这种实现的优点：
- 不需要加分布式锁，性能较好
- 实现简单，由数据库保证原子性

缺点：
- 在并发量高的情况下，会有较多失败操作，用户体验不佳
- 每次都要查询数据库，性能消耗较大

如果需要优化，可以考虑：
1. 使用Redis进行库存预检
2. 使用消息队列削峰
3. 采用悲观锁策略

---

_**User**_

voucherService.update()是mybatis-plus自带的函数吗

---

_**Assistant**_

是的，`voucherService.update()`是MyBatis-Plus提供的内置方法。

让我详细解释一下这个更新操作的链式调用：

```java
voucherService.update()  // ①
    .setSql("stock = stock - 1")  // ②
    .eq("voucher_id", voucherId)  // ③
    .eq("stock", voucher.getStock())  // ④
    .update();  // ⑤
```

这里用到了MyBatis-Plus的几个重要特性：

1. `update()`：
   - 来自`IService`接口（MyBatis-Plus提供）
   - 返回`LambdaUpdateWrapper`对象，支持链式调用

2. `setSql()`：
   - 用于设置要更新的SQL片段
   - 相当于SQL中的`SET`子句

3. `eq()`：
   - 等价于SQL中的`WHERE column = value`
   - 可以多次调用，多个条件之间是`AND`关系

4. 最后的`update()`：
   - 执行更新操作
   - 返回布尔值，表示更新是否成功

对应的SQL语句大致是：
```sql
UPDATE voucher 
SET stock = stock - 1
WHERE voucher_id = #{voucherId} 
AND stock = #{stock}
```

如果您想了解更多MyBatis-Plus的内置方法，可以参考：
- 增删改查接口：`IService`
- 条件构造器：`UpdateWrapper`
- 链式调用：`LambdaUpdateWrapper`

---

_**User**_

那如何解决在并发量高的情况下，会有较多秒杀失败操作，用户体验不佳的问题呢？我引用部分做一个简单的判断条件修改能否奏效

---

_**Assistant**_

我理解您想优化用户体验的想法。在高并发秒杀场景下，主要有以下几种优化方案：

1. **使用Redis预减库存**
- 在Redis中提前保存库存数量
- 先在Redis中进行库存预减，成功后再操作数据库
- 可以显著减少数据库压力

2. **使用消息队列**
- 将秒杀请求放入消息队列
- 异步处理订单创建和库存扣减
- 可以平滑流量峰值

3. **分布式锁**
- 使用Redis或Zookeeper实现分布式锁
- 保证同一用户不能重复下单

这里给出一个使用Redis预减库存的示例实现：

```java
@Override
@Transactional
public Result seckillVoucher(Long voucherId) {
    // 1. 从Redis中查询库存是否充足
    String stockKey = SECKILL_STOCK_KEY + voucherId;
    Long stock = stringRedisTemplate.opsForValue().decrement(stockKey);
    
    if (stock < 0) {
        // Redis中库存不足，直接返回
        stringRedisTemplate.opsForValue().increment(stockKey);
        return Result.fail("库存不足");
    }
    
    try {
        // 2. Redis预减成功后，再操作数据库
        boolean success = voucherService.update()
            .setSql("stock = stock - 1")
            .eq("voucher_id", voucherId)
            .gt("stock", 0)
            .update();
            
        if (!success) {
            // 数据库更新失败，Redis库存补偿
            stringRedisTemplate.opsForValue().increment(stockKey);
            return Result.fail("库存不足");
        }
        
        // 3. 创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // ... 订单创建逻辑 ...
        
        return Result.ok(orderId);
    } catch (Exception e) {
        // 异常情况下，Redis库存补偿
        stringRedisTemplate.opsForValue().increment(stockKey);
        throw e;
    }
}
```

这个方案的优点：
1. 大部分库存不足的请求可以在Redis层被拦截，减少数据库压力
2. 通过Redis的原子操作保证库存准确性
3. 添加了异常补偿机制，保证数据一致性

需要注意的是：
1. 需要提前将库存信息预热到Redis中
2. 要考虑Redis和数据库的数据一致性问题
3. 可能需要定时任务同步Redis和数据库的库存数据

如果需要更高的并发支持，还可以考虑引入消息队列，将下单请求异步化处理。这样可以进一步提升系统的承载能力。

---

_**User**_

以上基于悲观锁实现一人一单的代码存在什么问题？是否会有事务失效的可能性？请你帮我分析

---

_**Assistant**_

是的，这段代码存在事务失效的问题。让我分析一下：

1. **事务失效问题**
```java:src/main/java/com/hmdp/service/impl/VoucherOrderServiceImpl.java
// 外层方法
public Result seckillVoucher(Long voucherId) {
    Long userId = UserHolder.getUser().getId();
    synchronized (userId.toString().intern()) {
        // 这里调用的是this.createVoucherOrder，是当前对象的方法调用
        // 而不是代理对象的方法调用，导致@Transactional注解失效
        return this.createVoucherOrder(voucherId);
    }
}

@Transactional
private Result createVoucherOrder(Long voucherId) {
    // ... 创建订单逻辑
}
```

主要问题：
1. Spring的事务是通过代理对象来实现的
2. 在当前对象内部使用this调用另一个方法时，使用的是对象本身而不是代理对象
3. 因此，`@Transactional`注解不会生效

2. **锁的粒度问题**
- `userId.toString().intern()`虽然保证了同一用户的String对象是同一个，但在分布式环境下无法保证一人一单

正确的实现方式应该是：

```java:src/main/java/com/hmdp/service/impl/VoucherOrderServiceImpl.java
@Autowired
private IVoucherOrderService proxy; // 注入代理对象

public Result seckillVoucher(Long voucherId) {
    // 获取用户
    Long userId = UserHolder.getUser().getId();
    // 创建锁对象
    synchronized (userId.toString().intern()) {
        // 通过代理对象调用事务方法
        return proxy.createVoucherOrder(voucherId);
    }
}

@Transactional
public Result createVoucherOrder(Long voucherId) {
    // 一人一单逻辑
    Long userId = UserHolder.getUser().getId();
    
    // 查询订单
    int count = query().eq("user_id", userId)
            .eq("voucher_id", voucherId).count();
    if (count > 0) {
        return Result.fail("用户已经购买过一次！");
    }

    // 扣减库存
    boolean success = voucherService.update()
            .setSql("stock = stock - 1")
            .eq("voucher_id", voucherId)
            .gt("stock", 0)
            .update();
    if (!success) {
        return Result.fail("库存不足！");
    }

    // 创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // ... 设置订单信息 ...
    save(voucherOrder);
    
    return Result.ok(voucherOrder.getId());
}
```

优化建议：
1. 在分布式环境下，建议使用分布式锁替代synchronized
2. 可以考虑使用Redis实现分布式锁：
```java
private static final DefaultRedisScript<Long> SECKILL_SCRIPT;
static {
    SECKILL_SCRIPT = new DefaultRedisScript<>();
    SECKILL_SCRIPT.setLocation(new ClassPathResource("seckill.lua"));
    SECKILL_SCRIPT.setResultType(Long.class);
}

public Result seckillVoucher(Long voucherId) {
    Long userId = UserHolder.getUser().getId();
    // 执行lua脚本
    Long result = stringRedisTemplate.execute(
            SECKILL_SCRIPT,
            Collections.emptyList(),
            voucherId.toString(), userId.toString()
    );
    // 判断结果
    int r = result.intValue();
    if (r != 0) {
        return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
    }
    // 创建订单
    return proxy.createVoucherOrder(voucherId);
}
```

这样可以：
1. 确保事务正常工作
2. 在分布式环境下也能保证一人一单
3. 通过Redis和Lua脚本提高并发性能

---

_**User**_

这样修改事务失效问题是否是正确的，请你帮我分析与你提供的方案有什么区别

---

_**Assistant**_



是的，使用`AopContext.currentProxy()`获取代理对象也是一个正确的解决方案。让我分析两种方案的区别：

1. **通过`@Autowired`注入代理对象**
```java
@Autowired
private IVoucherOrderService proxy;
```

2. **通过`AopContext.currentProxy()`获取代理对象**
```java
IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
```

主要区别：

1. **配置要求**
   - `@Autowired`方案：无需额外配置
   - `AopContext.currentProxy()`方案：需要额外配置以启用AopContext
   ```java
   @EnableAspectJAutoProxy(exposeProxy = true)  // 需要添加此注解
   ```

2. **代理对象的生命周期**
   - `@Autowired`：代理对象在Spring容器启动时就被创建和注入
   - `AopContext.currentProxy()`：在方法调用时动态获取当前代理对象

3. **循环依赖风险**
   - `@Autowired`：可能导致循环依赖问题
   - `AopContext.currentProxy()`：不会有循环依赖问题

4. **性能影响**
   - `@Autowired`：性能较好，因为是直接使用已创建的代理对象
   - `AopContext.currentProxy()`：每次调用都需要获取代理对象，性能略差

5. **代码可维护性**
   - `@Autowired`：依赖注入更符合Spring的设计理念
   - `AopContext.currentProxy()`：代码更直观，明确表示获取当前代理对象

您使用的方案（`AopContext.currentProxy()`）是完全正确的，而且在这个场景下可能更合适，因为：

1. 避免了可能的循环依赖问题
2. 代码更直观，容易理解
3. 性能差异在这个场景下影响很小（秒杀接口本身就不是高频调用）

完整的正确实现应该是：

```java:src/main/java/com/hmdp/service/impl/VoucherOrderServiceImpl.java
@EnableAspectJAutoProxy(exposeProxy = true)  // 在配置类中添加此注解
public class VoucherOrderServiceImpl {
    
    @Override
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        synchronized (userId.toString().intern()) {
            // 获取代理对象
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        }
    }
    
    @Transactional
    public Result createVoucherOrder(Long voucherId) {
        // 一人一单逻辑
        // 扣减库存
        // 创建订单
    }
}
```

两种方案都能解决事务失效问题，选择哪种主要取决于：
1. 是否愿意添加额外的配置（`@EnableAspectJAutoProxy`）
2. 是否担心循环依赖问题
3. 个人对代码风格的偏好

在这个具体场景下，您使用的`AopContext.currentProxy()`方案是很好的选择。

---

_**User**_

但是以上方案在单体项目 单服务器部署时没有问题，如果基于多服务器的分布式部署架构下，多台机器是基于各自的JVM，这个基于JVM锁的方案是否就无法让不同JVM中的进程互斥，从而还是无法实现一人一单的功能

---

_**Assistant**_



是的，您说得对！在分布式环境下，基于`synchronized`的JVM级别的锁确实无法实现跨服务器的互斥，需要使用分布式锁来解决这个问题。

让我们用Redis实现分布式锁来优化这个方案：

```java:src/main/java/com/hmdp/service/impl/VoucherOrderServiceImpl.java
@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    
    @Override
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        // 1.创建锁的key
        String lockKey = "lock:order:" + userId;
        
        // 2.获取分布式锁
        boolean isLock = tryLock(lockKey);
        if (!isLock) {
            return Result.fail("不允许重复下单");
        }
        
        try {
            // 3.获取代理对象
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        } finally {
            // 4.释放锁
            unlock(lockKey);
        }
    }
    
    private boolean tryLock(String key) {
        Boolean flag = stringRedisTemplate.opsForValue()
                .setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(flag);
    }
    
    private void unlock(String key) {
        stringRedisTemplate.delete(key);
    }
    
    @Transactional
    public Result createVoucherOrder(Long voucherId) {
        // 一人一单逻辑
        Long userId = UserHolder.getUser().getId();
        
        // 查询订单
        int count = query().eq("user_id", userId)
                .eq("voucher_id", voucherId).count();
        if (count > 0) {
            return Result.fail("用户已经购买过一次！");
        }

        // 扣减库存
        boolean success = voucherService.update()
                .setSql("stock = stock - 1")
                .eq("voucher_id", voucherId)
                .gt("stock", 0)
                .update();
        if (!success) {
            return Result.fail("库存不足！");
        }

        // 创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // ... 设置订单信息 ...
        save(voucherOrder);
        
        return Result.ok(orderId);
    }
}
```

更进一步的优化，我们可以使用Lua脚本来确保原子性：

```java:src/main/java/com/hmdp/service/impl/VoucherOrderServiceImpl.java
public class VoucherOrderServiceImpl {
    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;
    static {
        SECKILL_SCRIPT = new DefaultRedisScript<>();
        SECKILL_SCRIPT.setLocation(new ClassPathResource("seckill.lua"));
        SECKILL_SCRIPT.setResultType(Long.class);
    }

    @Override
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        // 执行lua脚本
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.emptyList(),
                voucherId.toString(), userId.toString()
        );
        // 判断结果
        int r = result.intValue();
        if (r != 0) {
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        // 获取代理对象
        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
        return proxy.createVoucherOrder(voucherId);
    }
}
```

对应的Lua脚本（`seckill.lua`）：
```lua
-- 1.参数列表
local voucherId = ARGV[1]
local userId = ARGV[2]

-- 2.数据key
local stockKey = 'seckill:stock:' .. voucherId
local orderKey = 'seckill:order:' .. voucherId

-- 3.脚本业务
-- 3.1.判断库存是否充足
if(tonumber(redis.call('get', stockKey)) <= 0) then
    return 1
end

-- 3.2.判断用户是否下单
if(redis.call('sismember', orderKey, userId) == 1) then
    return 2
end

-- 3.3.扣库存
redis.call('incrby', stockKey, -1)
-- 3.4.下单（保存用户）
redis.call('sadd', orderKey, userId)

return 0
```

这个优化方案的优点：
1. 使用Redis分布式锁，解决了多服务器部署的问题
2. 使用Lua脚本保证了操作的原子性
3. 通过Redis预判库存和一人一单，减少了数据库压力
4. 保留了事务特性，确保数据一致性

需要注意的问题：
1. Redis的可用性（可以考虑Redis集群）
2. 分布式锁的超时时间设置
3. Redis和数据库的数据一致性问题

---

_**User**_

如果不使用Lua脚本保证了操作的原子性，会存在什么问题，我设想了这样一种情况，请你分析其在目前代码逻辑下是否会发生：锁名称一样，但是锁的线程标识不一样。线程1判断后发现锁的线程标识和当前线程一样，于是根据锁名释放锁，但是业务阻塞，锁超时释放，线程2拿到同样名称的锁，线程1根据锁名称把线程2的锁误删了

---

_**Assistant**_

是的，您分析得非常准确。在当前的实现中确实存在这个问题，让我详细分析这个场景：

1. **问题场景时序**：
```
时刻1: 线程1获取锁成功
  - 锁名称: lock:order:1
  - 线程标识: uuid-1

时刻2: 线程1业务阻塞，锁超时自动释放

时刻3: 线程2获取锁成功
  - 锁名称: lock:order:1
  - 线程标识: uuid-2

时刻4: 线程1继续执行到解锁逻辑
  - 获取锁中的标识（此时是uuid-2）
  - 比较自己的标识（uuid-1）
  - 误删了线程2的锁
```

2. **代码中的问题**：

```34:45:src/main/java/com/hmdp/utils/SimpleRedisLock.java
    @Override
    public void unlock() {
        // 获取线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        // 获取锁中的线程标识
        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
        // 判断是否一致
        if(threadId.equals(id)){
            // 释放锁
            stringRedisTemplate.delete(KEY_PREFIX + name);
        }
    }
```

在这段代码中，获取锁标识和删除锁的操作是分两步执行的，不是原子操作。

3. **正确的实现方式**应该使用Lua脚本：
```lua
-- 释放锁的Lua脚本
if redis.call('get', KEYS[1]) == ARGV[1] then
    return redis.call('del', KEYS[1])
else
    return 0
end
```

```java
public void unlock() {
    // 调用Lua脚本
    stringRedisTemplate.execute(
        UNLOCK_SCRIPT,
        Collections.singletonList(KEY_PREFIX + name),
        ID_PREFIX + Thread.currentThread().getId()
    );
}
```

4. **使用Lua脚本的优势**：
   - 保证原子性：判断和删除是一个原子操作
   - 避免误删：只有当锁的标识与当前线程标识相同时才会删除
   - 防止竞态条件：避免在判断和删除之间的时间窗口出现问题

这个问题在分布式环境下尤其重要，因为它可能导致：
1. 锁的误删除
2. 并发安全问题
3. 业务逻辑混乱

因此，在实现分布式锁时，使用Lua脚本来保证原子性是非常必要的。

---

_**User**_

什么时候会发生线程1业务阻塞呢？请你为我举例说明

---

_**Assistant**_



在秒杀业务场景中，线程阻塞可能发生在多个地方，我来举几个具体的例子：

1. **数据库操作阻塞**
```java:src/main/java/com/hmdp/service/impl/VoucherOrderServiceImpl.java
@Transactional
public Result createVoucherOrder(Long voucherId) {
    // 一人一单逻辑
    Long userId = UserHolder.getUser().getId();
    
    // 1. 查询订单 - 可能阻塞
    int count = query().eq("user_id", userId)
            .eq("voucher_id", voucherId).count();
            
    // 2. 扣减库存 - 可能阻塞
    boolean success = voucherService.update()
            .setSql("stock = stock - 1")
            .eq("voucher_id", voucherId)
            .gt("stock", 0)
            .update();
            
    // 3. 创建订单 - 可能阻塞
    VoucherOrder voucherOrder = new VoucherOrder();
    // ... 保存订单
    save(voucherOrder);
}
```

阻塞原因：
- 数据库连接池耗尽
- 数据库性能瓶颈
- 死锁等待
- 大量并发导致数据库响应慢

2. **网络延迟**
```java
// 远程调用其他服务 - 可能阻塞
Result payResult = payService.deductMoney(userId, amount);
```

阻塞原因：
- 网络拥塞
- 目标服务响应慢
- 网络抖动

3. **GC（垃圾回收）暂停**
```java
// 大量对象创建和销毁
for (VoucherOrder order : orderList) {
    // 处理订单逻辑
    processOrder(order);  // 期间可能发生GC
}
```

4. **线程池队列满**
```java
@Resource
private ThreadPoolExecutor executor;

public void processOrder() {
    // 线程池队列满时，提交新任务会阻塞
    executor.submit(() -> {
        // 处理订单逻辑
    });
}
```

5. **具体场景示例**：

```java
public Result seckillVoucher(Long voucherId) {
    Long userId = UserHolder.getUser().getId();
    // 创建锁对象 - 10秒超时
    SimpleRedisLock lock = new SimpleRedisLock(stringRedisTemplate, "order:" + userId);
    boolean isLock = lock.tryLock(10);
    
    if(isLock){
        try {
            // 以下操作可能耗时超过10秒
            // 1. 检查订单
            checkOrder();  // 数据库查询可能阻塞
            
            // 2. 扣减库存
            reduceStock();  // 数据库更新可能阻塞
            
            // 3. 创建订单
            createOrder();  // 数据库插入可能阻塞
            
            // 4. 远程调用支付服务
            payOrder();     // 网络调用可能阻塞
            
            // 如果以上操作总耗时超过10秒
            // 锁会自动释放，但线程还在执行
            // 这时其他线程可能获取到锁
            
        } finally {
            // 当前线程执行完毕后，可能会误删其他线程持有的锁
            lock.unlock();
        }
    }
}
```

解决方案：

1. **使用Lua脚本保证解锁操作的原子性**
```java
public void unlock() {
    // 使用Lua脚本，保证判断和删除的原子性
    stringRedisTemplate.execute(
        UNLOCK_SCRIPT,
        Collections.singletonList(KEY_PREFIX + name),
        ID_PREFIX + Thread.currentThread().getId()
    );
}
```

2. **合理设置锁的超时时间**
- 根据业务的最大执行时间来设置
- 考虑添加续期机制（看门狗机制）

3. **添加锁的续期机制**
```java
private void renewLock() {
    Timer timer = new Timer();
    timer.scheduleAtFixedRate(new TimerTask() {
        @Override
        public void run() {
            if (threadId.equals(getThreadId())) {
                stringRedisTemplate.expire(KEY_PREFIX + name, 10, TimeUnit.SECONDS);
            }
        }
    }, 5000, 5000);
}
```

这些场景都可能导致业务执行时间超过锁的超时时间，从而引发锁失效的问题。因此在实际开发中，需要：
1. 合理评估业务执行时间
2. 实现可靠的锁机制
3. 考虑添加锁续期功能
4. 做好异常处理和降级机制

---

_**User**_

上述你分析的这种锁误删情况，是因为锁名称中不含有独特的线程标识，能否在锁名称中加入一定的标识来避免这种情况呢？这是否会是更简单的解决方案


---

_**Assistant**_



实际上，即使在锁名称中加入线程标识也不能完全解决这个问题。让我解释一下：

假设我们修改锁名称的生成方式：
```java:src/main/java/com/hmdp/utils/SimpleRedisLock.java
public class SimpleRedisLock {
    public boolean tryLock(long timeoutSec) {
        // 获取线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        // 锁名称加入线程标识
        String lockKey = KEY_PREFIX + name + ":" + threadId;
        Boolean success = stringRedisTemplate.opsForValue()
            .setIfAbsent(lockKey, threadId, timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
}
```

这样做会带来新的问题：

1. **无法保证互斥**
- 不同线程会生成不同的锁名称
- 导致多个线程可以同时获取"锁"
- 失去了分布式锁的互斥性

例如：
```
线程1的锁名称: lock:order:1:uuid-1
线程2的锁名称: lock:order:1:uuid-2
```
这样两个线程都能成功获取锁，无法达到互斥的目的。

2. **业务逻辑问题**
在秒杀场景中，我们需要的是：
```java
// 一个用户同时只能有一个下单操作
String lockKey = "lock:order:" + userId;
```

而不是：
```java
// 这样会导致同一用户可以同时多次下单
String lockKey = "lock:order:" + userId + ":" + threadId;
```

因此，正确的解决方案还是应该：
1. 保持锁名称的业务语义
2. 在锁的值中包含线程标识
3. 使用Lua脚本保证解锁操作的原子性

```java:src/main/java/com/hmdp/utils/SimpleRedisLock.java
public class SimpleRedisLock {
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }
    
    public boolean tryLock(long timeoutSec) {
        // 锁名称保持业务语义
        String lockKey = KEY_PREFIX + name;
        // 值中包含线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue()
            .setIfAbsent(lockKey, threadId, timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    
    public void unlock() {
        // 使用Lua脚本保证原子性
        stringRedisTemplate.execute(
            UNLOCK_SCRIPT,
            Collections.singletonList(KEY_PREFIX + name),
            ID_PREFIX + Thread.currentThread().getId()
        );
    }
}
```

这样既保证了业务正确性，又解决了锁误删的问题。

---



---

